%-- Axioms defining a key-value store
%-- The key-value store is represented as an array
%-- With keys being integers, and values being nonnegative integers
%-- Null is represented as -1
%-- Heavy inspiration from examples/array.smt2 from https://bitbucket.org/peba123/smttotptp/src/master/
%-- Axioms are heavily inspired from "The Vampire and the FOOL" 2016

tff(get,type,
    get: ( $array($int,$int) * $int ) > $int ).

tff(put,type,
    put: ( $array($int,$int) * $int * $int ) > $array($int,$int) ).

%-- Removal at a specified index
tff(remove,type,
    remove: ( $array($int,$int) * $int ) > $array($int,$int) ).

tff(contains,type,
    contains: ( $array($int,$int) * $int ) > $o ).

%---∀ a:Array[Int, Int] i:Int e:Int ((a[i] ← e)[i] = e)
tff(read_over_write_one,axiom,
    ! [A: $array($int,$int),I: $int,E: $int] :
      ( $greatereq(E,0)
     => ( get(put(A,I,E),I) = E ) ) ).

%---∀ a:Array[Int, Int] i:Int j:Int e:Int ((i ≠ j) ⇒ ((a[i] ← e)[j] = a[j]))
tff(read_over_write_two,axiom,
    ! [A: $array($int,$int),I: $int,J: $int,E: $int] :
      ( ( ( I != J )
        & $greatereq(E,0) )
     => ( get(put(A,I,E),J) = get(A,J) ) ) ).

%---∀ a:Array[Int, Int] b:Array[Int, Int] (∀ i:Int (a[i] = b[i]) ⇒ (a = b))
tff(extensionality,axiom,
    ! [A: $array($int,$int),B: $array($int,$int)] :
      ( ! [I: $int] : ( get(A,I) = get(B,I) )
     => ( A = B ) ) ).

tff(contains_def_one,axiom,
    ! [A: $array($int,$int),V: $int] :
      ( contains(A,V)
    <=> ? [I: $int] : ( get(A,I) = V ) ) ).

tff(contains_def_two,axiom,
    ! [A: $array($int,$int), I:$int, V:$int] :
     (contains(put(A,I,V),V))).

tff(contains_def_three,axiom,
    ![A:$array($int,$int), B:$array($int,$int)]:
    ((![V:$int]: (contains(A,V) <=> contains(B,V))) => A = B)).

tff(removal_def,axiom,
    ![A:$array($int,$int), I:$int] :
    (get(remove(A,I),I) = $uminus(1))).

tff(read_over_remove,axiom,
    ![A:$array($int,$int), I:$int, J:$int] : 
     ((I != J) => get(remove(A,I),J) = get(A,J))).

%-- Brainstorming removal axioms
%-- Getting a removed element just gives you -1 ig, this works over all keys, i.e, you can remove a removed value
%-- You can put after removing and get that, essentially read_over_write_one with more steps
%-- I want it that it is IMPOSSIBLE for you to prove something with a null element, which I think changing my initial axioms helped with
%-- read_over_write_two with removal instead of put
%-- If 2 arrays are equal and then you remove a valid element from one, they should no longer be equal

