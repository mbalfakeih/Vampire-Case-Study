include('lists.ax').
%-- Axioms defining a key-value store
%-- The key-value store is represented as an array.
%-- The key-value store is of length n, with a hash function of (k modulo n)
%-- In case of hash collisons, we use lists for separate chaining
%-- Keys and values are both integers

%-- Length of the key-value store
tff(length,type,
    n: $int ).

%-- Key-Value store must be non-empty
tff(length_pos,axiom,
    $greater(n,0) ).

%-- Heavy inspiration from examples/array.smt2 from https://bitbucket.org/peba123/smttotptp/src/master/
%-- Axioms are heavily inspired from "The Vampire and the FOOL" 2016

%-- Key-Value Store function declarations
%-- This will either return a nil, or cons(pair_cons(K,V),nil)
tff(get,type,
    get: ( $array($int,list) * $int ) > list ).

%-- Does not allow for duplicate keys, these will be replaced
%-- Second argument is the key, third is the value
tff(put,type,
    put: ( $array($int,list) * $int * $int ) > $array($int,list) ).

%-- Removal at a specified index
tff(remove,type,
    remove: ( $array($int,list) * $int ) > $array($int,list) ).

tff(contains,type,
    contains: ( $array($int,list) * $int ) > $o ).

tff(size,type,
    size: $array($int,list) > $int ).

%-- Helper functions
%-- This will return an entire chain in the key-value store
tff(get_chain,type,
    get_chain: ( $array($int,list) * $int ) > list ).

%-- Function definitions
%-- These do not suffice to be able to prove properties of key-value stores, 
%-- these exist to ensure none of the following axioms contradict the function defintions
tff(get_chain_def,axiom,
    ! [A: $array($int,list),K: $int] : ( get_chain(A,K) = $select(A,$remainder_e(K,n)) ) ).

tff(get_def,axiom,
    ! [A: $array($int,list),K: $int] : ( get(A,K) = get_l(get_chain(A,K),K) ) ).

tff(remove_def,axiom,
    ! [A: $array($int,list),K: $int] : ( remove(A,K) = $store(A,$remainder_e(K,n),remove_l(get_chain(A,K),K)) ) ).

tff(put_def,axiom,
    ! [A: $array($int,list),K: $int,V: $int] : ( put(A,K,V) = $store(remove(A,K),K,append(cons(pair_cons(K,V),nil),get_chain(remove(A,K),K))) ) ).

tff(contains_def,axiom,
    ! [A: $array($int,list),V:$int] : ( contains(A,V) <=> (? [K: $int] : (get(A,K) = cons(pair_cons(K,V),nil)) ))).



%-- Concrete key-value store
tff(kvs,type,
    kvs: $array($int,list) ).

tff(set_length,axiom,
    n = 5 ).

tff(init_kvs,axiom,
    ! [I: $int] :
      ( ( $greatereq(I,0)
        & $less(I,n) )
     => ( get_chain(kvs,I) = nil ) ) ).

tff(get_chain_kvs,conjecture,
get_chain(kvs,6) = get_chain(kvs,1)).


%--tff(get_kvs,conjecture,
%--    get(put(kvs,1,2),1) = cons(pair_cons(1,2),nil)).

