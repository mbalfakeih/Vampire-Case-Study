%Note that includes are defined relative to the prove_properties.sh script
include('axioms/pairs.ax').
%-- List definitions heavily inspired from: https://tptp.org/cgi-bin/SeeTPTP?Category=Problems&Domain=DAT&File=DAT081_1.p
tff(list,type,
    list: $tType ).

tff(nil,type,
    nil: list ).

tff(cons,type,
    cons: ( pair * list ) > list ).

tff(head,type,
    head: list > pair ).

tff(tail,type,
    tail: list > list ).

%----Selectors
tff(head_def,axiom,
    ! [P: pair,L: list] : ( head(cons(P,L)) = P ) ).

tff(tail_def,axiom,
    ! [P: pair,L: list] : ( tail(cons(P,L)) = L ) ).

%----Constructors
tff(list_constructors,axiom,
    ! [L: list] :
      ( ( L = nil )
      | ( L = cons(head(L),tail(L)) ) ) ).

tff(cons_requirement,axiom,
    ! [P: pair,L: list] : ( cons(P,L) != nil ) ).

%----List membership
tff(in,type,
    in: ( $int * list ) > $o ).

tff(in_conv,axiom,
    ! [X: $int,L: list] :
      ( in(X,L)
    <=> ( ? [H: pair,T: list] :
            ( ( L = cons(H,T) )
            & ( X = get_right(H) ) )
        | ? [H: pair,T: list] :
            ( ( L = cons(H,T) )
            & in(X,T) ) ) ) ).

%----Length
tff(length_l,type,
    length_l: list > $int ).

tff(length_l_def_nil,axiom,
    length_l(nil) = 0 ).

tff(length_l_def_cons,axiom,
    ! [P: pair,L: list] : ( length_l(cons(P,L)) = $sum(1,length_l(L)) ) ).

%----Append
tff(append,type,
    append: ( list * list ) > list ).

tff(append_def_one,axiom,
    ! [L: list] : ( append(nil,L) = L ) ).

tff(append_def_two,axiom,
    ! [P: pair,K: list,L: list] : ( append(cons(P,K),L) = cons(P,append(K,L)) ) ).

%----Remove
tff(remove_l,type,
    remove_l: ( list * $int ) > list ).

tff(remove_nil,axiom,
    ! [I: $int] : ( remove_l(nil,I) = nil ) ).

tff(remove_from_list,axiom,
    ! [L: list,I: $int] :
      ( ( L != nil )
     => ( remove_l(L,I) = $ite(get_left(head(L)) = I,tail(L),cons(head(L),remove_l(tail(L),I))) ) ) ).

%----Get
tff(get_l,type,
    get_l: ( list * $int ) > list ).

tff(get_nil,axiom,
    ! [I: $int] : ( get_l(nil,I) = nil ) ).

tff(get_from_list,axiom,
    ! [L: list,I: $int] :
      ( ( L != nil )
     => ( get_l(L,I) = $ite(get_left(head(L)) = I,cons(head(L),nil),get_l(tail(L),I)) ) ) ).

%----Vampire does not seem to be able to prove this
%----My assumption is this is due to struggles with induction
%----This was attempted with different induction schedules (induction and struct_induction)
tff(get_result,axiom,
    ! [L: list,I: $int] :
      ( ( get_l(L,I) = nil )
      | ? [P: pair] : ( get_l(L,I) = cons(P,nil) ) ) ).

%----This also can't be proven, I'm guessing due to the complexity of the get_l function
%----But honestly I'm not sure how to simplify it without somehow having a none value for pair
tff(get_key,axiom,
    ! [L: list,I: $int] :
      ( ( get_l(L,I) != nil )
     => ( get_left(head(get_l(L,I))) = I ) ) ).

%----Lemmas
tff(get_result_length,lemma,
    ! [L: list,I: $int] :
      ( ( length_l(get_l(L,I)) = 0 )
      | ( length_l(get_l(L,I)) = 1 ) ) ).

%-- Basic tests
%--tff(mk_list,type,
%--    mk_list: list ).

%--tff(a,axiom,
%--    mk_list = cons(pair_cons(1,2),nil) ).

%--tff(c,conjecture,head(mk_list)=pair_cons(1,2)).
%--tff(d,conjecture,remove_l(mk_list,1)=nil).
%--tff(e,conjecture,remove_l(mk_list,2)=mk_list).
%--tff(f,conjecture,~in(1,mk_list)).
%--tff(g,conjecture,get_l(mk_list,2)=nil).
%--tff(h,conjecture,length_l(mk_list)=1).
